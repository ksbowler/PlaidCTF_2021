import sys
from Crypto.Util.number import *
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

n = 572900899020416333871774257897548190887875148332377649724629936942125065954403900214957099848244171042974830846321891115307194396859686148130195132775076147750816194194669485148310306866581747110109691391312495531105927432103095764487512855459663872226168973095665437985144973023035595602765438245069834002841752496072121527638243974956820747758308700622999731497265472265365706764203471894277850225555548962683741076063801485180774626107811063013748877832840560423294386298604594493033408101188433615350326658252746536427284017654908082042006370318751764459634138015874523739235598764251156235537699918418385721276093786930034069514119606912034739140729411915149355415250809598641184778583967357160241141516039721817350339432544637530638228659667851395488664406233933526970325653567096968977127473742267040558971420711170242569029577549402889853450812286141680939789725346428838857690827772743624748319239951407607711869461490939565401926953995816761514931996533209601647238748877564442428220404985707296616973140792150179655494712897659250302854615541193197046051998966799951879589911393813337960444303479065771250762320802542931155305758806716461516379431800232991995334538124086322560806306237096858377000246068189144665458605879

x = 16158503035655503426113161923582139215996816729841729510388257123879913978158886398099119284865182008994209960822918533986492024494600106348146394391522057566608094710459034761239411826561975763233251722937911293380163746384471886598967490683174505277425790076708816190844068727460135370229854070720638780344789626637927699732624476246512446229279134683464388038627051524453190148083707025054101132463059634405171130015990728153311556498299145863647112326468089494225289395728401221863674961839497514512905495012562702779156196970731085339939466059770413224786385677222902726546438487688076765303358036256878804074494


M = 2048

binn = str(bin(n))[2:]
binx = str(bin(x))[2:]
binx = "0" + binx
sys.setrecursionlimit(3000)
def recur(tp,tq):
	#再帰でpを求める。tp,tqはp,qの候補の値
	#求めたらpを返し、現在のtp,tqでは求められないのであればFalseを返す
	bits = len(tp)
	if bits == M:
		#tpが2048bitsになった場合
		p = int(tp,2)
		if n%p == 0:
			print("Find!")
			print(p)
			return p
		#nで割った余りが0でないから、tpはpではない
		return False
	tn = int(tp,2)*int(tq,2)
	if str(bin(tn))[-bits:] != binn[-bits:]:
		#tp,tqの積の下位x bits (xはtpの長さ。変数bitsと同義)がnの下位x bitsと異なるのであれば、tp,tqはp,qの候補値から外れる。
		return False

	#xの値より、tp,tqに追加すべき候補は２通りに絞られる
	if binx[-(bits+1)] == "1":
		p = recur("1"+tp,"0"+tq)
		if p: return p

		p = recur("0"+tp,"1"+tq)
		if p: return p
	else:
		p = recur("1"+tp,"1"+tq)
		if p: return p

		p = recur("0"+tp,"0"+tq)
		if p: return p

	return False

p = recur("11","01")
q = n//p
e = 65537
phi = (p-1)*(q-1)
d = inverse(e,phi)
f = open("./dist/flag.enc","rb")
a = f.readlines()
key = RSA.construct((n,e,d,p,q))
cipher = PKCS1_OAEP.new(key)
ciphertext = a[0] + a[1][:-1] #最後の改行が入ると悪さをするのでそれを抜く
flag = cipher.decrypt(ciphertext)
print(flag)
